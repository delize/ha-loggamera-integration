#!/usr/bin/env python3
"""
Loggamera Update Frequency Analyzer

This script analyzes log files generated by monitor_powermeter_updates.py
to provide statistics about update patterns and recommend optimal polling intervals.

Usage:
  python analyze_update_frequency.py LOG_FILE

Example:
  python analyze_update_frequency.py powermeter_logs/powermeter_device_9729_20230518_120000.log
"""

import sys
import re
import argparse
from datetime import datetime
import statistics
import matplotlib.pyplot as plt
import numpy as np
import os

def parse_log(log_file):
    """Parse the log file and extract update timestamps."""
    update_times = []
    poll_times = []
    poll_pattern = r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}) - INFO - Poll #\d+'
    update_pattern = r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},\d{3}) - INFO - UPDATE DETECTED!'
    
    try:
        with open(log_file, 'r') as f:
            for line in f:
                # Check for poll timestamps
                poll_match = re.search(poll_pattern, line)
                if poll_match:
                    timestamp_str = poll_match.group(1)
                    try:
                        timestamp = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S,%f')
                        poll_times.append(timestamp)
                    except ValueError:
                        continue
                
                # Check for update timestamps
                update_match = re.search(update_pattern, line)
                if update_match:
                    timestamp_str = update_match.group(1)
                    try:
                        timestamp = datetime.strptime(timestamp_str, '%Y-%m-%d %H:%M:%S,%f')
                        update_times.append(timestamp)
                    except ValueError:
                        continue
    except FileNotFoundError:
        print(f"Error: File {log_file} not found")
        sys.exit(1)
    except Exception as e:
        print(f"Error parsing log file: {e}")
        sys.exit(1)
    
    return poll_times, update_times

def calculate_intervals(timestamps):
    """Calculate time intervals between timestamps in minutes."""
    if len(timestamps) < 2:
        return []
    
    intervals = []
    for i in range(1, len(timestamps)):
        interval = (timestamps[i] - timestamps[i-1]).total_seconds() / 60
        intervals.append(interval)
    
    return intervals

def analyze_updates(poll_times, update_times):
    """Analyze update patterns and return statistics."""
    if not update_times:
        return {
            "updates": 0,
            "polls": len(poll_times),
            "update_intervals": [],
            "avg_interval": None,
            "min_interval": None,
            "max_interval": None,
            "median_interval": None,
            "std_dev": None,
            "recommended_interval": None
        }
    
    # Calculate intervals between updates
    update_intervals = calculate_intervals(update_times)
    
    # Calculate statistics
    avg_interval = statistics.mean(update_intervals) if update_intervals else None
    min_interval = min(update_intervals) if update_intervals else None
    max_interval = max(update_intervals) if update_intervals else None
    median_interval = statistics.median(update_intervals) if update_intervals else None
    std_dev = statistics.stdev(update_intervals) if len(update_intervals) > 1 else None
    
    # Calculate recommended polling interval (half of average interval, but at least 5 minutes)
    if avg_interval:
        recommended_interval = max(5, round(avg_interval / 2))
    else:
        recommended_interval = None
    
    # Calculate update frequency
    update_frequency = len(update_times) / len(poll_times) if poll_times else 0
    
    return {
        "updates": len(update_times),
        "polls": len(poll_times),
        "update_intervals": update_intervals,
        "update_frequency": update_frequency,
        "avg_interval": avg_interval,
        "min_interval": min_interval,
        "max_interval": max_interval,
        "median_interval": median_interval,
        "std_dev": std_dev,
        "recommended_interval": recommended_interval
    }

def generate_histogram(update_intervals, output_file=None):
    """Generate a histogram of update intervals."""
    try:
        import matplotlib.pyplot as plt
        
        if not update_intervals:
            print("No update intervals to plot")
            return
        
        plt.figure(figsize=(10, 6))
        
        # Create histogram
        n, bins, patches = plt.hist(update_intervals, bins=20, alpha=0.7, color='skyblue', edgecolor='black')
        
        # Add vertical line for the average
        avg = statistics.mean(update_intervals)
        plt.axvline(avg, color='red', linestyle='dashed', linewidth=1, label=f'Mean: {avg:.2f} min')
        
        # Add vertical line for the median
        median = statistics.median(update_intervals)
        plt.axvline(median, color='green', linestyle='dashed', linewidth=1, label=f'Median: {median:.2f} min')
        
        # Add recommended polling interval
        recommended = max(5, round(avg / 2))
        plt.axvline(recommended, color='orange', linestyle='dashed', linewidth=1, label=f'Recommended poll: {recommended} min')
        
        plt.xlabel('Update Interval (minutes)')
        plt.ylabel('Frequency')
        plt.title('Distribution of PowerMeter Update Intervals')
        plt.grid(axis='y', alpha=0.75)
        plt.legend()
        
        # Save or show the plot
        if output_file:
            plt.savefig(output_file)
            print(f"Histogram saved to {output_file}")
        else:
            plt.show()
        
    except ImportError:
        print("Matplotlib not installed. Skipping histogram generation.")
    except Exception as e:
        print(f"Error generating histogram: {e}")

def print_report(stats):
    """Print a report of the analysis."""
    print("\n===== LOGGAMERA UPDATE FREQUENCY ANALYSIS =====\n")
    
    print(f"Total polls: {stats['polls']}")
    print(f"Total updates detected: {stats['updates']}")
    
    if stats['updates'] > 0:
        print(f"Update frequency: {stats['update_frequency']*100:.2f}% of polls contained updates")
        
        print("\nUpdate interval statistics (minutes):")
        print(f"- Average: {stats['avg_interval']:.2f}")
        print(f"- Median: {stats['median_interval']:.2f}")
        print(f"- Minimum: {stats['min_interval']:.2f}")
        print(f"- Maximum: {stats['max_interval']:.2f}")
        print(f"- Standard deviation: {stats['std_dev']:.2f}")
        
        print("\nRecommended settings:")
        print(f"- Polling interval: {stats['recommended_interval']} minutes ({stats['recommended_interval']*60} seconds)")
        
        if stats['avg_interval'] > 25:
            print("\nNOTE: Data appears to update approximately every 30 minutes.")
            print("This matches the expected behavior for PowerMeter devices.")
            print("The recommended polling interval balances timely updates with API efficiency.")
    else:
        print("\nNo updates detected in the log. Consider running the monitoring script for longer.")

def main():
    """Run the script."""
    parser = argparse.ArgumentParser(description='Analyze Loggamera update frequency from logs')
    parser.add_argument('log_file', help='Log file generated by monitor_powermeter_updates.py')
    parser.add_argument('--plot', action='store_true', help='Generate update interval histogram plot')
    parser.add_argument('--output', help='Output file for histogram (PNG format)')
    
    args = parser.parse_args()
    
    # Parse the log file
    poll_times, update_times = parse_log(args.log_file)
    
    if not poll_times:
        print("No poll times found in the log file")
        sys.exit(1)
    
    # Analyze the data
    stats = analyze_updates(poll_times, update_times)
    
    # Print report
    print_report(stats)
    
    # Generate histogram if requested
    if args.plot or args.output:
        output_file = args.output
        if not output_file and stats['updates'] > 1:
            # Create plots directory if it doesn't exist
            os.makedirs("update_analysis_plots", exist_ok=True)
            
            # Generate output filename based on log filename
            log_basename = os.path.basename(args.log_file)
            output_file = f"update_analysis_plots/{os.path.splitext(log_basename)[0]}_histogram.png"
        
        if stats['updates'] > 1:
            generate_histogram(stats['update_intervals'], output_file)
        else:
            print("Not enough updates for histogram generation")

if __name__ == "__main__":
    main()